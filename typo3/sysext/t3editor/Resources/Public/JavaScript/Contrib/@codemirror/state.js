class Text{lineAt(t){if(t<0||t>this.length)throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);return this.lineInner(t,!1,1,0)}line(t){if(t<1||t>this.lines)throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);return this.lineInner(t,!0,1,0)}replace(t,e,n){[t,e]=clip(this,t,e);let i=[];return this.decompose(0,t,i,2),n.length&&n.decompose(0,n.length,i,3),this.decompose(e,this.length,i,1),TextNode.from(i,this.length-(e-t)+n.length)}append(t){return this.replace(this.length,this.length,t)}slice(t,e=this.length){[t,e]=clip(this,t,e);let n=[];return this.decompose(t,e,n,0),TextNode.from(n,e-t)}eq(t){if(t==this)return!0;if(t.length!=this.length||t.lines!=this.lines)return!1;let e=this.scanIdentical(t,1),n=this.length-this.scanIdentical(t,-1),i=new RawTextCursor(this),r=new RawTextCursor(t);for(let t=e,s=e;;){if(i.next(t),r.next(t),t=0,i.lineBreak!=r.lineBreak||i.done!=r.done||i.value!=r.value)return!1;if(s+=i.value.length,i.done||s>=n)return!0}}iter(t=1){return new RawTextCursor(this,t)}iterRange(t,e=this.length){return new PartialTextCursor(this,t,e)}iterLines(t,e){let n;if(null==t)n=this.iter();else{null==e&&(e=this.lines+1);let i=this.line(t).from;n=this.iterRange(i,Math.max(i,e==this.lines+1?this.length:e<=1?0:this.line(e-1).to))}return new LineCursor(n)}toString(){return this.sliceString(0)}toJSON(){let t=[];return this.flatten(t),t}constructor(){}static of(t){if(0==t.length)throw new RangeError("A document must have at least one line");return 1!=t.length||t[0]?t.length<=32?new TextLeaf(t):TextNode.from(TextLeaf.split(t,[])):Text.empty}}class TextLeaf extends Text{constructor(t,e=textLength(t)){super(),this.text=t,this.length=e}get lines(){return this.text.length}get children(){return null}lineInner(t,e,n,i){for(let r=0;;r++){let s=this.text[r],o=i+s.length;if((e?n:o)>=t)return new Line(i,o,n,s);i=o+1,n++}}decompose(t,e,n,i){let r=t<=0&&e>=this.length?this:new TextLeaf(sliceText(this.text,t,e),Math.min(e,this.length)-Math.max(0,t));if(1&i){let t=n.pop(),e=appendText(r.text,t.text.slice(),0,r.length);if(e.length<=32)n.push(new TextLeaf(e,t.length+r.length));else{let t=e.length>>1;n.push(new TextLeaf(e.slice(0,t)),new TextLeaf(e.slice(t)))}}else n.push(r)}replace(t,e,n){if(!(n instanceof TextLeaf))return super.replace(t,e,n);[t,e]=clip(this,t,e);let i=appendText(this.text,appendText(n.text,sliceText(this.text,0,t)),e),r=this.length+n.length-(e-t);return i.length<=32?new TextLeaf(i,r):TextNode.from(TextLeaf.split(i,[]),r)}sliceString(t,e=this.length,n="\n"){[t,e]=clip(this,t,e);let i="";for(let r=0,s=0;r<=e&&s<this.text.length;s++){let o=this.text[s],a=r+o.length;r>t&&s&&(i+=n),t<a&&e>r&&(i+=o.slice(Math.max(0,t-r),e-r)),r=a+1}return i}flatten(t){for(let e of this.text)t.push(e)}scanIdentical(){return 0}static split(t,e){let n=[],i=-1;for(let r of t)n.push(r),i+=r.length+1,32==n.length&&(e.push(new TextLeaf(n,i)),n=[],i=-1);return i>-1&&e.push(new TextLeaf(n,i)),e}}class TextNode extends Text{constructor(t,e){super(),this.children=t,this.length=e,this.lines=0;for(let e of t)this.lines+=e.lines}lineInner(t,e,n,i){for(let r=0;;r++){let s=this.children[r],o=i+s.length,a=n+s.lines-1;if((e?a:o)>=t)return s.lineInner(t,e,n,i);i=o+1,n=a+1}}decompose(t,e,n,i){for(let r=0,s=0;s<=e&&r<this.children.length;r++){let o=this.children[r],a=s+o.length;if(t<=a&&e>=s){let r=i&((s<=t?1:0)|(a>=e?2:0));s>=t&&a<=e&&!r?n.push(o):o.decompose(t-s,e-s,n,r)}s=a+1}}replace(t,e,n){if([t,e]=clip(this,t,e),n.lines<this.lines)for(let i=0,r=0;i<this.children.length;i++){let s=this.children[i],o=r+s.length;if(t>=r&&e<=o){let a=s.replace(t-r,e-r,n),h=this.lines-s.lines+a.lines;if(a.lines<h>>4&&a.lines>h>>6){let r=this.children.slice();return r[i]=a,new TextNode(r,this.length-(e-t)+n.length)}return super.replace(r,o,a)}r=o+1}return super.replace(t,e,n)}sliceString(t,e=this.length,n="\n"){[t,e]=clip(this,t,e);let i="";for(let r=0,s=0;r<this.children.length&&s<=e;r++){let o=this.children[r],a=s+o.length;s>t&&r&&(i+=n),t<a&&e>s&&(i+=o.sliceString(t-s,e-s,n)),s=a+1}return i}flatten(t){for(let e of this.children)e.flatten(t)}scanIdentical(t,e){if(!(t instanceof TextNode))return 0;let n=0,[i,r,s,o]=e>0?[0,0,this.children.length,t.children.length]:[this.children.length-1,t.children.length-1,-1,-1];for(;;i+=e,r+=e){if(i==s||r==o)return n;let a=this.children[i],h=t.children[r];if(a!=h)return n+a.scanIdentical(h,e);n+=a.length+1}}static from(t,e=t.reduce(((t,e)=>t+e.length+1),-1)){let n=0;for(let e of t)n+=e.lines;if(n<32){let n=[];for(let e of t)e.flatten(n);return new TextLeaf(n,e)}let i=Math.max(32,n>>5),r=i<<1,s=i>>1,o=[],a=0,h=-1,l=[];function c(t){let e;if(t.lines>r&&t instanceof TextNode)for(let e of t.children)c(e);else t.lines>s&&(a>s||!a)?(f(),o.push(t)):t instanceof TextLeaf&&a&&(e=l[l.length-1])instanceof TextLeaf&&t.lines+e.lines<=32?(a+=t.lines,h+=t.length+1,l[l.length-1]=new TextLeaf(e.text.concat(t.text),e.length+1+t.length)):(a+t.lines>i&&f(),a+=t.lines,h+=t.length+1,l.push(t))}function f(){0!=a&&(o.push(1==l.length?l[0]:TextNode.from(l,h)),h=-1,a=l.length=0)}for(let e of t)c(e);return f(),1==o.length?o[0]:new TextNode(o,e)}}function textLength(t){let e=-1;for(let n of t)e+=n.length+1;return e}function appendText(t,e,n=0,i=1e9){for(let r=0,s=0,o=!0;s<t.length&&r<=i;s++){let a=t[s],h=r+a.length;h>=n&&(h>i&&(a=a.slice(0,i-r)),r<n&&(a=a.slice(n-r)),o?(e[e.length-1]+=a,o=!1):e.push(a)),r=h+1}return e}function sliceText(t,e,n){return appendText(t,[""],e,n)}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(t,e=1){this.dir=e,this.done=!1,this.lineBreak=!1,this.value="",this.nodes=[t],this.offsets=[e>0?1:(t instanceof TextLeaf?t.text.length:t.children.length)<<1]}nextInner(t,e){for(this.done=this.lineBreak=!1;;){let n=this.nodes.length-1,i=this.nodes[n],r=this.offsets[n],s=r>>1,o=i instanceof TextLeaf?i.text.length:i.children.length;if(s==(e>0?o:0)){if(0==n)return this.done=!0,this.value="",this;e>0&&this.offsets[n-1]++,this.nodes.pop(),this.offsets.pop()}else if((1&r)==(e>0?0:1)){if(this.offsets[n]+=e,0==t)return this.lineBreak=!0,this.value="\n",this;t--}else if(i instanceof TextLeaf){let r=i.text[s+(e<0?-1:0)];if(this.offsets[n]+=e,r.length>Math.max(0,t))return this.value=0==t?r:e>0?r.slice(t):r.slice(0,r.length-t),this;t-=r.length}else{let r=i.children[s+(e<0?-1:0)];t>r.length?(t-=r.length,this.offsets[n]+=e):(e<0&&this.offsets[n]--,this.nodes.push(r),this.offsets.push(e>0?1:(r instanceof TextLeaf?r.text.length:r.children.length)<<1))}}}next(t=0){return t<0&&(this.nextInner(-t,-this.dir),t=this.value.length),this.nextInner(t,this.dir)}}class PartialTextCursor{constructor(t,e,n){this.value="",this.done=!1,this.cursor=new RawTextCursor(t,e>n?-1:1),this.pos=e>n?t.length:0,this.from=Math.min(e,n),this.to=Math.max(e,n)}nextInner(t,e){if(e<0?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;t+=Math.max(0,e<0?this.pos-this.to:this.from-this.pos);let n=e<0?this.pos-this.from:this.to-this.pos;t>n&&(t=n),n-=t;let{value:i}=this.cursor.next(t);return this.pos+=(i.length+t)*e,this.value=i.length<=n?i:e<0?i.slice(i.length-n):i.slice(0,n),this.done=!this.value,this}next(t=0){return t<0?t=Math.max(t,this.from-this.pos):t>0&&(t=Math.min(t,this.to-this.pos)),this.nextInner(t,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(t){this.inner=t,this.afterBreak=!0,this.value="",this.done=!1}next(t=0){let{done:e,lineBreak:n,value:i}=this.inner.next(t);return e&&this.afterBreak?(this.value="",this.afterBreak=!1):e?(this.done=!0,this.value=""):n?this.afterBreak?this.value="":(this.afterBreak=!0,this.next()):(this.value=i,this.afterBreak=!1),this}get lineBreak(){return!1}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this});class Line{constructor(t,e,n,i){this.from=t,this.to=e,this.number=n,this.text=i}get length(){return this.to-this.from}}function clip(t,e,n){return[e=Math.max(0,Math.min(t.length,e)),Math.max(e,Math.min(t.length,n))]}let extend="lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t=>t?parseInt(t,36):1));for(let t=1;t<extend.length;t++)extend[t]+=extend[t-1];function isExtendingChar(t){for(let e=1;e<extend.length;e+=2)if(extend[e]>t)return extend[e-1]<=t;return!1}function isRegionalIndicator(t){return t>=127462&&t<=127487}const ZWJ=8205;function findClusterBreak(t,e,n=!0,i=!0){return(n?nextClusterBreak:prevClusterBreak)(t,e,i)}function nextClusterBreak(t,e,n){if(e==t.length)return e;e&&surrogateLow(t.charCodeAt(e))&&surrogateHigh(t.charCodeAt(e-1))&&e--;let i=codePointAt(t,e);for(e+=codePointSize(i);e<t.length;){let r=codePointAt(t,e);if(i==ZWJ||r==ZWJ||n&&isExtendingChar(r))e+=codePointSize(r),i=r;else{if(!isRegionalIndicator(r))break;{let n=0,i=e-2;for(;i>=0&&isRegionalIndicator(codePointAt(t,i));)n++,i-=2;if(n%2==0)break;e+=2}}}return e}function prevClusterBreak(t,e,n){for(;e>0;){let i=nextClusterBreak(t,e-2,n);if(i<e)return i;e--}return 0}function surrogateLow(t){return t>=56320&&t<57344}function surrogateHigh(t){return t>=55296&&t<56320}function codePointAt(t,e){let n=t.charCodeAt(e);if(!surrogateHigh(n)||e+1==t.length)return n;let i=t.charCodeAt(e+1);return surrogateLow(i)?i-56320+(n-55296<<10)+65536:n}function fromCodePoint(t){return t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10),56320+(1023&t)))}function codePointSize(t){return t<65536?1:2}const DefaultSplit=/\r\n?|\n/;var MapMode=function(t){return t[t.Simple=0]="Simple",t[t.TrackDel=1]="TrackDel",t[t.TrackBefore=2]="TrackBefore",t[t.TrackAfter=3]="TrackAfter",t}(MapMode||(MapMode={}));class ChangeDesc{constructor(t){this.sections=t}get length(){let t=0;for(let e=0;e<this.sections.length;e+=2)t+=this.sections[e];return t}get newLength(){let t=0;for(let e=0;e<this.sections.length;e+=2){let n=this.sections[e+1];t+=n<0?this.sections[e]:n}return t}get empty(){return 0==this.sections.length||2==this.sections.length&&this.sections[1]<0}iterGaps(t){for(let e=0,n=0,i=0;e<this.sections.length;){let r=this.sections[e++],s=this.sections[e++];s<0?(t(n,i,r),i+=r):i+=s,n+=r}}iterChangedRanges(t,e=!1){iterChanges(this,t,e)}get invertedDesc(){let t=[];for(let e=0;e<this.sections.length;){let n=this.sections[e++],i=this.sections[e++];i<0?t.push(n,i):t.push(i,n)}return new ChangeDesc(t)}composeDesc(t){return this.empty?t:t.empty?this:composeSets(this,t)}mapDesc(t,e=!1){return t.empty?this:mapSet(this,t,e)}mapPos(t,e=-1,n=MapMode.Simple){let i=0,r=0;for(let s=0;s<this.sections.length;){let o=this.sections[s++],a=this.sections[s++],h=i+o;if(a<0){if(h>t)return r+(t-i);r+=o}else{if(n!=MapMode.Simple&&h>=t&&(n==MapMode.TrackDel&&i<t&&h>t||n==MapMode.TrackBefore&&i<t||n==MapMode.TrackAfter&&h>t))return null;if(h>t||h==t&&e<0&&!o)return t==i||e<0?r:r+a;r+=a}i=h}if(t>i)throw new RangeError(`Position ${t} is out of range for changeset of length ${i}`);return r}touchesRange(t,e=t){for(let n=0,i=0;n<this.sections.length&&i<=e;){let r=i+this.sections[n++];if(this.sections[n++]>=0&&i<=e&&r>=t)return!(i<t&&r>e)||"cover";i=r}return!1}toString(){let t="";for(let e=0;e<this.sections.length;){let n=this.sections[e++],i=this.sections[e++];t+=(t?" ":"")+n+(i>=0?":"+i:"")}return t}toJSON(){return this.sections}static fromJSON(t){if(!Array.isArray(t)||t.length%2||t.some((t=>"number"!=typeof t)))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(t)}static create(t){return new ChangeDesc(t)}}class ChangeSet extends ChangeDesc{constructor(t,e){super(t),this.inserted=e}apply(t){if(this.length!=t.length)throw new RangeError("Applying change set to a document with the wrong length");return iterChanges(this,((e,n,i,r,s)=>t=t.replace(i,i+(n-e),s)),!1),t}mapDesc(t,e=!1){return mapSet(this,t,e,!0)}invert(t){let e=this.sections.slice(),n=[];for(let i=0,r=0;i<e.length;i+=2){let s=e[i],o=e[i+1];if(o>=0){e[i]=o,e[i+1]=s;let a=i>>1;for(;n.length<a;)n.push(Text.empty);n.push(s?t.slice(r,r+s):Text.empty)}r+=s}return new ChangeSet(e,n)}compose(t){return this.empty?t:t.empty?this:composeSets(this,t,!0)}map(t,e=!1){return t.empty?this:mapSet(this,t,e,!0)}iterChanges(t,e=!1){iterChanges(this,t,e)}get desc(){return ChangeDesc.create(this.sections)}filter(t){let e=[],n=[],i=[],r=new SectionIter(this);t:for(let s=0,o=0;;){let a=s==t.length?1e9:t[s++];for(;o<a||o==a&&0==r.len;){if(r.done)break t;let t=Math.min(r.len,a-o);addSection(i,t,-1);let s=-1==r.ins?-1:0==r.off?r.ins:0;addSection(e,t,s),s>0&&addInsert(n,e,r.text),r.forward(t),o+=t}let h=t[s++];for(;o<h;){if(r.done)break t;let t=Math.min(r.len,h-o);addSection(e,t,-1),addSection(i,t,-1==r.ins?-1:0==r.off?r.ins:0),r.forward(t),o+=t}}return{changes:new ChangeSet(e,n),filtered:ChangeDesc.create(i)}}toJSON(){let t=[];for(let e=0;e<this.sections.length;e+=2){let n=this.sections[e],i=this.sections[e+1];i<0?t.push(n):0==i?t.push([n]):t.push([n].concat(this.inserted[e>>1].toJSON()))}return t}static of(t,e,n){let i=[],r=[],s=0,o=null;function a(t=!1){if(!t&&!i.length)return;s<e&&addSection(i,e-s,-1);let n=new ChangeSet(i,r);o=o?o.compose(n.map(o)):n,i=[],r=[],s=0}return function t(h){if(Array.isArray(h))for(let e of h)t(e);else if(h instanceof ChangeSet){if(h.length!=e)throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${e})`);a(),o=o?o.compose(h.map(o)):h}else{let{from:t,to:o=t,insert:l}=h;if(t>o||t<0||o>e)throw new RangeError(`Invalid change range ${t} to ${o} (in doc of length ${e})`);let c=l?"string"==typeof l?Text.of(l.split(n||DefaultSplit)):l:Text.empty,f=c.length;if(t==o&&0==f)return;t<s&&a(),t>s&&addSection(i,t-s,-1),addSection(i,o-t,f),addInsert(r,i,c),s=o}}(t),a(!o),o}static empty(t){return new ChangeSet(t?[t,-1]:[],[])}static fromJSON(t){if(!Array.isArray(t))throw new RangeError("Invalid JSON representation of ChangeSet");let e=[],n=[];for(let i=0;i<t.length;i++){let r=t[i];if("number"==typeof r)e.push(r,-1);else{if(!Array.isArray(r)||"number"!=typeof r[0]||r.some(((t,e)=>e&&"string"!=typeof t)))throw new RangeError("Invalid JSON representation of ChangeSet");if(1==r.length)e.push(r[0],0);else{for(;n.length<i;)n.push(Text.empty);n[i]=Text.of(r.slice(1)),e.push(r[0],n[i].length)}}}return new ChangeSet(e,n)}static createSet(t,e){return new ChangeSet(t,e)}}function addSection(t,e,n,i=!1){if(0==e&&n<=0)return;let r=t.length-2;r>=0&&n<=0&&n==t[r+1]?t[r]+=e:0==e&&0==t[r]?t[r+1]+=n:i?(t[r]+=e,t[r+1]+=n):t.push(e,n)}function addInsert(t,e,n){if(0==n.length)return;let i=e.length-2>>1;if(i<t.length)t[t.length-1]=t[t.length-1].append(n);else{for(;t.length<i;)t.push(Text.empty);t.push(n)}}function iterChanges(t,e,n){let i=t.inserted;for(let r=0,s=0,o=0;o<t.sections.length;){let a=t.sections[o++],h=t.sections[o++];if(h<0)r+=a,s+=a;else{let l=r,c=s,f=Text.empty;for(;l+=a,c+=h,h&&i&&(f=f.append(i[o-2>>1])),!(n||o==t.sections.length||t.sections[o+1]<0);)a=t.sections[o++],h=t.sections[o++];e(r,l,s,c,f),r=l,s=c}}}function mapSet(t,e,n,i=!1){let r=[],s=i?[]:null,o=new SectionIter(t),a=new SectionIter(e);for(let t=-1;;)if(-1==o.ins&&-1==a.ins){let t=Math.min(o.len,a.len);addSection(r,t,-1),o.forward(t),a.forward(t)}else if(a.ins>=0&&(o.ins<0||t==o.i||0==o.off&&(a.len<o.len||a.len==o.len&&!n))){let e=a.len;for(addSection(r,a.ins,-1);e;){let n=Math.min(o.len,e);o.ins>=0&&t<o.i&&o.len<=n&&(addSection(r,0,o.ins),s&&addInsert(s,r,o.text),t=o.i),o.forward(n),e-=n}a.next()}else{if(!(o.ins>=0)){if(o.done&&a.done)return s?ChangeSet.createSet(r,s):ChangeDesc.create(r);throw new Error("Mismatched change set lengths")}{let e=0,n=o.len;for(;n;)if(-1==a.ins){let t=Math.min(n,a.len);e+=t,n-=t,a.forward(t)}else{if(!(0==a.ins&&a.len<n))break;n-=a.len,a.next()}addSection(r,e,t<o.i?o.ins:0),s&&t<o.i&&addInsert(s,r,o.text),t=o.i,o.forward(o.len-n)}}}function composeSets(t,e,n=!1){let i=[],r=n?[]:null,s=new SectionIter(t),o=new SectionIter(e);for(let t=!1;;){if(s.done&&o.done)return r?ChangeSet.createSet(i,r):ChangeDesc.create(i);if(0==s.ins)addSection(i,s.len,0,t),s.next();else if(0!=o.len||o.done){if(s.done||o.done)throw new Error("Mismatched change set lengths");{let e=Math.min(s.len2,o.len),n=i.length;if(-1==s.ins){let n=-1==o.ins?-1:o.off?0:o.ins;addSection(i,e,n,t),r&&n&&addInsert(r,i,o.text)}else-1==o.ins?(addSection(i,s.off?0:s.len,e,t),r&&addInsert(r,i,s.textBit(e))):(addSection(i,s.off?0:s.len,o.off?0:o.ins,t),r&&!o.off&&addInsert(r,i,o.text));t=(s.ins>e||o.ins>=0&&o.len>e)&&(t||i.length>n),s.forward2(e),o.forward(e)}}else addSection(i,0,o.ins,t),r&&addInsert(r,i,o.text),o.next()}}class SectionIter{constructor(t){this.set=t,this.i=0,this.next()}next(){let{sections:t}=this.set;this.i<t.length?(this.len=t[this.i++],this.ins=t[this.i++]):(this.len=0,this.ins=-2),this.off=0}get done(){return-2==this.ins}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:t}=this.set,e=this.i-2>>1;return e>=t.length?Text.empty:t[e]}textBit(t){let{inserted:e}=this.set,n=this.i-2>>1;return n>=e.length&&!t?Text.empty:e[n].slice(this.off,null==t?void 0:this.off+t)}forward(t){t==this.len?this.next():(this.len-=t,this.off+=t)}forward2(t){-1==this.ins?this.forward(t):t==this.ins?this.next():(this.ins-=t,this.off+=t)}}class SelectionRange{constructor(t,e,n){this.from=t,this.to=e,this.flags=n}get anchor(){return 32&this.flags?this.to:this.from}get head(){return 32&this.flags?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return 8&this.flags?-1:16&this.flags?1:0}get bidiLevel(){let t=7&this.flags;return 7==t?null:t}get goalColumn(){let t=this.flags>>6;return 16777215==t?void 0:t}map(t,e=-1){let n,i;return this.empty?n=i=t.mapPos(this.from,e):(n=t.mapPos(this.from,1),i=t.mapPos(this.to,-1)),n==this.from&&i==this.to?this:new SelectionRange(n,i,this.flags)}extend(t,e=t){if(t<=this.anchor&&e>=this.anchor)return EditorSelection.range(t,e);let n=Math.abs(t-this.anchor)>Math.abs(e-this.anchor)?t:e;return EditorSelection.range(this.anchor,n)}eq(t,e=!1){return!(this.anchor!=t.anchor||this.head!=t.head||e&&this.empty&&this.assoc!=t.assoc)}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(t){if(!t||"number"!=typeof t.anchor||"number"!=typeof t.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(t.anchor,t.head)}static create(t,e,n){return new SelectionRange(t,e,n)}}class EditorSelection{constructor(t,e){this.ranges=t,this.mainIndex=e}map(t,e=-1){return t.empty?this:EditorSelection.create(this.ranges.map((n=>n.map(t,e))),this.mainIndex)}eq(t,e=!1){if(this.ranges.length!=t.ranges.length||this.mainIndex!=t.mainIndex)return!1;for(let n=0;n<this.ranges.length;n++)if(!this.ranges[n].eq(t.ranges[n],e))return!1;return!0}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main],0)}addRange(t,e=!0){return EditorSelection.create([t].concat(this.ranges),e?0:this.mainIndex+1)}replaceRange(t,e=this.mainIndex){let n=this.ranges.slice();return n[e]=t,EditorSelection.create(n,this.mainIndex)}toJSON(){return{ranges:this.ranges.map((t=>t.toJSON())),main:this.mainIndex}}static fromJSON(t){if(!t||!Array.isArray(t.ranges)||"number"!=typeof t.main||t.main>=t.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(t.ranges.map((t=>SelectionRange.fromJSON(t))),t.main)}static single(t,e=t){return new EditorSelection([EditorSelection.range(t,e)],0)}static create(t,e=0){if(0==t.length)throw new RangeError("A selection needs at least one range");for(let n=0,i=0;i<t.length;i++){let r=t[i];if(r.empty?r.from<=n:r.from<n)return EditorSelection.normalized(t.slice(),e);n=r.to}return new EditorSelection(t,e)}static cursor(t,e=0,n,i){return SelectionRange.create(t,t,(0==e?0:e<0?8:16)|(null==n?7:Math.min(6,n))|(null!=i?i:16777215)<<6)}static range(t,e,n,i){let r=(null!=n?n:16777215)<<6|(null==i?7:Math.min(6,i));return e<t?SelectionRange.create(e,t,48|r):SelectionRange.create(t,e,(e>t?8:0)|r)}static normalized(t,e=0){let n=t[e];t.sort(((t,e)=>t.from-e.from)),e=t.indexOf(n);for(let n=1;n<t.length;n++){let i=t[n],r=t[n-1];if(i.empty?i.from<=r.to:i.from<r.to){let s=r.from,o=Math.max(i.to,r.to);n<=e&&e--,t.splice(--n,2,i.anchor>i.head?EditorSelection.range(o,s):EditorSelection.range(s,o))}}return new EditorSelection(t,e)}}function checkSelection(t,e){for(let n of t.ranges)if(n.to>e)throw new RangeError("Selection points outside of document")}let nextID=0;class Facet{constructor(t,e,n,i,r){this.combine=t,this.compareInput=e,this.compare=n,this.isStatic=i,this.id=nextID++,this.default=t([]),this.extensions="function"==typeof r?r(this):r}get reader(){return this}static define(t={}){return new Facet(t.combine||(t=>t),t.compareInput||((t,e)=>t===e),t.compare||(t.combine?(t,e)=>t===e:sameArray),!!t.static,t.enables)}of(t){return new FacetProvider([],this,0,t)}compute(t,e){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(t,this,1,e)}computeN(t,e){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(t,this,2,e)}from(t,e){return e||(e=t=>t),this.compute([t],(n=>e(n.field(t))))}}function sameArray(t,e){return t==e||t.length==e.length&&t.every(((t,n)=>t===e[n]))}class FacetProvider{constructor(t,e,n,i){this.dependencies=t,this.facet=e,this.type=n,this.value=i,this.id=nextID++}dynamicSlot(t){var e;let n=this.value,i=this.facet.compareInput,r=this.id,s=t[r]>>1,o=2==this.type,a=!1,h=!1,l=[];for(let n of this.dependencies)"doc"==n?a=!0:"selection"==n?h=!0:0==(1&(null!==(e=t[n.id])&&void 0!==e?e:1))&&l.push(t[n.id]);return{create:t=>(t.values[s]=n(t),1),update(t,e){if(a&&e.docChanged||h&&(e.docChanged||e.selection)||ensureAll(t,l)){let e=n(t);if(o?!compareArray(e,t.values[s],i):!i(e,t.values[s]))return t.values[s]=e,1}return 0},reconfigure:(t,e)=>{let a,h=e.config.address[r];if(null!=h){let r=getAddr(e,h);if(this.dependencies.every((n=>n instanceof Facet?e.facet(n)===t.facet(n):!(n instanceof StateField)||e.field(n,!1)==t.field(n,!1)))||(o?compareArray(a=n(t),r,i):i(a=n(t),r)))return t.values[s]=r,0}else a=n(t);return t.values[s]=a,1}}}}function compareArray(t,e,n){if(t.length!=e.length)return!1;for(let i=0;i<t.length;i++)if(!n(t[i],e[i]))return!1;return!0}function ensureAll(t,e){let n=!1;for(let i of e)1&ensureAddr(t,i)&&(n=!0);return n}function dynamicFacetSlot(t,e,n){let i=n.map((e=>t[e.id])),r=n.map((t=>t.type)),s=i.filter((t=>!(1&t))),o=t[e.id]>>1;function a(t){let n=[];for(let e=0;e<i.length;e++){let s=getAddr(t,i[e]);if(2==r[e])for(let t of s)n.push(t);else n.push(s)}return e.combine(n)}return{create(t){for(let e of i)ensureAddr(t,e);return t.values[o]=a(t),1},update(t,n){if(!ensureAll(t,s))return 0;let i=a(t);return e.compare(i,t.values[o])?0:(t.values[o]=i,1)},reconfigure(t,r){let s=ensureAll(t,i),h=r.config.facets[e.id],l=r.facet(e);if(h&&!s&&sameArray(n,h))return t.values[o]=l,0;let c=a(t);return e.compare(c,l)?(t.values[o]=l,0):(t.values[o]=c,1)}}}const initField=Facet.define({static:!0});class StateField{constructor(t,e,n,i,r){this.id=t,this.createF=e,this.updateF=n,this.compareF=i,this.spec=r,this.provides=void 0}static define(t){let e=new StateField(nextID++,t.create,t.update,t.compare||((t,e)=>t===e),t);return t.provide&&(e.provides=t.provide(e)),e}create(t){let e=t.facet(initField).find((t=>t.field==this));return((null==e?void 0:e.create)||this.createF)(t)}slot(t){let e=t[this.id]>>1;return{create:t=>(t.values[e]=this.create(t),1),update:(t,n)=>{let i=t.values[e],r=this.updateF(i,n);return this.compareF(i,r)?0:(t.values[e]=r,1)},reconfigure:(t,n)=>null!=n.config.address[this.id]?(t.values[e]=n.field(this),0):(t.values[e]=this.create(t),1)}}init(t){return[this,initField.of({field:this,create:t})]}get extension(){return this}}const Prec_={lowest:4,low:3,default:2,high:1,highest:0};function prec(t){return e=>new PrecExtension(e,t)}const Prec={highest:prec(Prec_.highest),high:prec(Prec_.high),default:prec(Prec_.default),low:prec(Prec_.low),lowest:prec(Prec_.lowest)};class PrecExtension{constructor(t,e){this.inner=t,this.prec=e}}class Compartment{of(t){return new CompartmentInstance(this,t)}reconfigure(t){return Compartment.reconfigure.of({compartment:this,extension:t})}get(t){return t.config.compartments.get(this)}}class CompartmentInstance{constructor(t,e){this.compartment=t,this.inner=e}}class Configuration{constructor(t,e,n,i,r,s){for(this.base=t,this.compartments=e,this.dynamicSlots=n,this.address=i,this.staticValues=r,this.facets=s,this.statusTemplate=[];this.statusTemplate.length<n.length;)this.statusTemplate.push(0)}staticFacet(t){let e=this.address[t.id];return null==e?t.default:this.staticValues[e>>1]}static resolve(t,e,n){let i=[],r=Object.create(null),s=new Map;for(let n of flatten(t,e,s))n instanceof StateField?i.push(n):(r[n.facet.id]||(r[n.facet.id]=[])).push(n);let o=Object.create(null),a=[],h=[];for(let t of i)o[t.id]=h.length<<1,h.push((e=>t.slot(e)));let l=null==n?void 0:n.config.facets;for(let t in r){let e=r[t],i=e[0].facet,s=l&&l[t]||[];if(e.every((t=>0==t.type)))if(o[i.id]=a.length<<1|1,sameArray(s,e))a.push(n.facet(i));else{let t=i.combine(e.map((t=>t.value)));a.push(n&&i.compare(t,n.facet(i))?n.facet(i):t)}else{for(let t of e)0==t.type?(o[t.id]=a.length<<1|1,a.push(t.value)):(o[t.id]=h.length<<1,h.push((e=>t.dynamicSlot(e))));o[i.id]=h.length<<1,h.push((t=>dynamicFacetSlot(t,i,e)))}}let c=h.map((t=>t(o)));return new Configuration(t,s,c,o,a,r)}}function flatten(t,e,n){let i=[[],[],[],[],[]],r=new Map;return function t(s,o){let a=r.get(s);if(null!=a){if(a<=o)return;let t=i[a].indexOf(s);t>-1&&i[a].splice(t,1),s instanceof CompartmentInstance&&n.delete(s.compartment)}if(r.set(s,o),Array.isArray(s))for(let e of s)t(e,o);else if(s instanceof CompartmentInstance){if(n.has(s.compartment))throw new RangeError("Duplicate use of compartment in extensions");let i=e.get(s.compartment)||s.inner;n.set(s.compartment,i),t(i,o)}else if(s instanceof PrecExtension)t(s.inner,s.prec);else if(s instanceof StateField)i[o].push(s),s.provides&&t(s.provides,o);else if(s instanceof FacetProvider)i[o].push(s),s.facet.extensions&&t(s.facet.extensions,Prec_.default);else{let e=s.extension;if(!e)throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);t(e,o)}}(t,Prec_.default),i.reduce(((t,e)=>t.concat(e)))}function ensureAddr(t,e){if(1&e)return 2;let n=e>>1,i=t.status[n];if(4==i)throw new Error("Cyclic dependency between fields and/or facets");if(2&i)return i;t.status[n]=4;let r=t.computeSlot(t,t.config.dynamicSlots[n]);return t.status[n]=2|r}function getAddr(t,e){return 1&e?t.config.staticValues[e>>1]:t.values[e>>1]}const languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:t=>t.some((t=>t)),static:!0}),lineSeparator=Facet.define({combine:t=>t.length?t[0]:void 0,static:!0}),changeFilter=Facet.define(),transactionFilter=Facet.define(),transactionExtender=Facet.define(),readOnly=Facet.define({combine:t=>!!t.length&&t[0]});class Annotation{constructor(t,e){this.type=t,this.value=e}static define(){return new AnnotationType}}class AnnotationType{of(t){return new Annotation(this,t)}}class StateEffectType{constructor(t){this.map=t}of(t){return new StateEffect(this,t)}}class StateEffect{constructor(t,e){this.type=t,this.value=e}map(t){let e=this.type.map(this.value,t);return void 0===e?void 0:e==this.value?this:new StateEffect(this.type,e)}is(t){return this.type==t}static define(t={}){return new StateEffectType(t.map||(t=>t))}static mapEffects(t,e){if(!t.length)return t;let n=[];for(let i of t){let t=i.map(e);t&&n.push(t)}return n}}StateEffect.reconfigure=StateEffect.define(),StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(t,e,n,i,r,s){this.startState=t,this.changes=e,this.selection=n,this.effects=i,this.annotations=r,this.scrollIntoView=s,this._doc=null,this._state=null,n&&checkSelection(n,e.newLength),r.some((t=>t.type==Transaction.time))||(this.annotations=r.concat(Transaction.time.of(Date.now())))}static create(t,e,n,i,r,s){return new Transaction(t,e,n,i,r,s)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){return this._state||this.startState.applyTransaction(this),this._state}annotation(t){for(let e of this.annotations)if(e.type==t)return e.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(t){let e=this.annotation(Transaction.userEvent);return!(!e||!(e==t||e.length>t.length&&e.slice(0,t.length)==t&&"."==e[t.length]))}}function joinRanges(t,e){let n=[];for(let i=0,r=0;;){let s,o;if(i<t.length&&(r==e.length||e[r]>=t[i]))s=t[i++],o=t[i++];else{if(!(r<e.length))return n;s=e[r++],o=e[r++]}!n.length||n[n.length-1]<s?n.push(s,o):n[n.length-1]<o&&(n[n.length-1]=o)}}function mergeTransaction(t,e,n){var i;let r,s,o;return n?(r=e.changes,s=ChangeSet.empty(e.changes.length),o=t.changes.compose(e.changes)):(r=e.changes.map(t.changes),s=t.changes.mapDesc(e.changes,!0),o=t.changes.compose(r)),{changes:o,selection:e.selection?e.selection.map(s):null===(i=t.selection)||void 0===i?void 0:i.map(r),effects:StateEffect.mapEffects(t.effects,r).concat(StateEffect.mapEffects(e.effects,s)),annotations:t.annotations.length?t.annotations.concat(e.annotations):e.annotations,scrollIntoView:t.scrollIntoView||e.scrollIntoView}}function resolveTransactionInner(t,e,n){let i=e.selection,r=asArray(e.annotations);return e.userEvent&&(r=r.concat(Transaction.userEvent.of(e.userEvent))),{changes:e.changes instanceof ChangeSet?e.changes:ChangeSet.of(e.changes||[],n,t.facet(lineSeparator)),selection:i&&(i instanceof EditorSelection?i:EditorSelection.single(i.anchor,i.head)),effects:asArray(e.effects),annotations:r,scrollIntoView:!!e.scrollIntoView}}function resolveTransaction(t,e,n){let i=resolveTransactionInner(t,e.length?e[0]:{},t.doc.length);e.length&&!1===e[0].filter&&(n=!1);for(let r=1;r<e.length;r++){!1===e[r].filter&&(n=!1);let s=!!e[r].sequential;i=mergeTransaction(i,resolveTransactionInner(t,e[r],s?i.changes.newLength:t.doc.length),s)}let r=Transaction.create(t,i.changes,i.selection,i.effects,i.annotations,i.scrollIntoView);return extendTransaction(n?filterTransaction(r):r)}function filterTransaction(t){let e=t.startState,n=!0;for(let i of e.facet(changeFilter)){let e=i(t);if(!1===e){n=!1;break}Array.isArray(e)&&(n=!0===n?e:joinRanges(n,e))}if(!0!==n){let i,r;if(!1===n)r=t.changes.invertedDesc,i=ChangeSet.empty(e.doc.length);else{let e=t.changes.filter(n);i=e.changes,r=e.filtered.mapDesc(e.changes).invertedDesc}t=Transaction.create(e,i,t.selection&&t.selection.map(r),StateEffect.mapEffects(t.effects,r),t.annotations,t.scrollIntoView)}let i=e.facet(transactionFilter);for(let n=i.length-1;n>=0;n--){let r=i[n](t);t=r instanceof Transaction?r:Array.isArray(r)&&1==r.length&&r[0]instanceof Transaction?r[0]:resolveTransaction(e,asArray(r),!1)}return t}function extendTransaction(t){let e=t.startState,n=e.facet(transactionExtender),i=t;for(let r=n.length-1;r>=0;r--){let s=n[r](t);s&&Object.keys(s).length&&(i=mergeTransaction(i,resolveTransactionInner(e,s,t.changes.newLength),!0))}return i==t?t:Transaction.create(e,t.changes,t.selection,i.effects,i.annotations,i.scrollIntoView)}Transaction.time=Annotation.define(),Transaction.userEvent=Annotation.define(),Transaction.addToHistory=Annotation.define(),Transaction.remote=Annotation.define();const none=[];function asArray(t){return null==t?none:Array.isArray(t)?t:[t]}var CharCategory=function(t){return t[t.Word=0]="Word",t[t.Space=1]="Space",t[t.Other=2]="Other",t}(CharCategory||(CharCategory={}));const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(t){}function hasWordChar(t){if(wordChar)return wordChar.test(t);for(let e=0;e<t.length;e++){let n=t[e];if(/\w/.test(n)||n>"Â€"&&(n.toUpperCase()!=n.toLowerCase()||nonASCIISingleCaseWordChar.test(n)))return!0}return!1}function makeCategorizer(t){return e=>{if(!/\S/.test(e))return CharCategory.Space;if(hasWordChar(e))return CharCategory.Word;for(let n=0;n<t.length;n++)if(e.indexOf(t[n])>-1)return CharCategory.Word;return CharCategory.Other}}class EditorState{constructor(t,e,n,i,r,s){this.config=t,this.doc=e,this.selection=n,this.values=i,this.status=t.statusTemplate.slice(),this.computeSlot=r,s&&(s._state=this);for(let t=0;t<this.config.dynamicSlots.length;t++)ensureAddr(this,t<<1);this.computeSlot=null}field(t,e=!0){let n=this.config.address[t.id];if(null!=n)return ensureAddr(this,n),getAddr(this,n);if(e)throw new RangeError("Field is not present in this state")}update(...t){return resolveTransaction(this,t,!0)}applyTransaction(t){let e,n=this.config,{base:i,compartments:r}=n;for(let e of t.effects)e.is(Compartment.reconfigure)?(n&&(r=new Map,n.compartments.forEach(((t,e)=>r.set(e,t))),n=null),r.set(e.value.compartment,e.value.extension)):e.is(StateEffect.reconfigure)?(n=null,i=e.value):e.is(StateEffect.appendConfig)&&(n=null,i=asArray(i).concat(e.value));if(n)e=t.startState.values.slice();else{n=Configuration.resolve(i,r,this),e=new EditorState(n,this.doc,this.selection,n.dynamicSlots.map((()=>null)),((t,e)=>e.reconfigure(t,this)),null).values}let s=t.startState.facet(allowMultipleSelections)?t.newSelection:t.newSelection.asSingle();new EditorState(n,t.newDoc,s,e,((e,n)=>n.update(e,t)),t)}replaceSelection(t){return"string"==typeof t&&(t=this.toText(t)),this.changeByRange((e=>({changes:{from:e.from,to:e.to,insert:t},range:EditorSelection.cursor(e.from+t.length)})))}changeByRange(t){let e=this.selection,n=t(e.ranges[0]),i=this.changes(n.changes),r=[n.range],s=asArray(n.effects);for(let n=1;n<e.ranges.length;n++){let o=t(e.ranges[n]),a=this.changes(o.changes),h=a.map(i);for(let t=0;t<n;t++)r[t]=r[t].map(h);let l=i.mapDesc(a,!0);r.push(o.range.map(l)),i=i.compose(h),s=StateEffect.mapEffects(s,h).concat(StateEffect.mapEffects(asArray(o.effects),l))}return{changes:i,selection:EditorSelection.create(r,e.mainIndex),effects:s}}changes(t=[]){return t instanceof ChangeSet?t:ChangeSet.of(t,this.doc.length,this.facet(EditorState.lineSeparator))}toText(t){return Text.of(t.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(t=0,e=this.doc.length){return this.doc.sliceString(t,e,this.lineBreak)}facet(t){let e=this.config.address[t.id];return null==e?t.default:(ensureAddr(this,e),getAddr(this,e))}toJSON(t){let e={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(t)for(let n in t){let i=t[n];i instanceof StateField&&null!=this.config.address[i.id]&&(e[n]=i.spec.toJSON(this.field(t[n]),this))}return e}static fromJSON(t,e={},n){if(!t||"string"!=typeof t.doc)throw new RangeError("Invalid JSON representation for EditorState");let i=[];if(n)for(let e in n)if(Object.prototype.hasOwnProperty.call(t,e)){let r=n[e],s=t[e];i.push(r.init((t=>r.spec.fromJSON(s,t))))}return EditorState.create({doc:t.doc,selection:EditorSelection.fromJSON(t.selection),extensions:e.extensions?i.concat([e.extensions]):i})}static create(t={}){let e=Configuration.resolve(t.extensions||[],new Map),n=t.doc instanceof Text?t.doc:Text.of((t.doc||"").split(e.staticFacet(EditorState.lineSeparator)||DefaultSplit)),i=t.selection?t.selection instanceof EditorSelection?t.selection:EditorSelection.single(t.selection.anchor,t.selection.head):EditorSelection.single(0);return checkSelection(i,n.length),e.staticFacet(allowMultipleSelections)||(i=i.asSingle()),new EditorState(e,n,i,e.dynamicSlots.map((()=>null)),((t,e)=>e.create(t)),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(t,...e){for(let e of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(e,t)){t=e[t];break}return e.length&&(t=t.replace(/\$(\$|\d*)/g,((t,n)=>{if("$"==n)return"$";let i=+(n||1);return!i||i>e.length?t:e[i-1]}))),t}languageDataAt(t,e,n=-1){let i=[];for(let r of this.facet(languageData))for(let s of r(this,e,n))Object.prototype.hasOwnProperty.call(s,t)&&i.push(s[t]);return i}charCategorizer(t){return makeCategorizer(this.languageDataAt("wordChars",t).join(""))}wordAt(t){let{text:e,from:n,length:i}=this.doc.lineAt(t),r=this.charCategorizer(t),s=t-n,o=t-n;for(;s>0;){let t=findClusterBreak(e,s,!1);if(r(e.slice(t,s))!=CharCategory.Word)break;s=t}for(;o<i;){let t=findClusterBreak(e,o);if(r(e.slice(o,t))!=CharCategory.Word)break;o=t}return s==o?null:EditorSelection.range(s+n,o+n)}}function combineConfig(t,e,n={}){let i={};for(let e of t)for(let t of Object.keys(e)){let r=e[t],s=i[t];if(void 0===s)i[t]=r;else if(s===r||void 0===r);else{if(!Object.hasOwnProperty.call(n,t))throw new Error("Config merge conflict for field "+t);i[t]=n[t](s,r)}}for(let t in e)void 0===i[t]&&(i[t]=e[t]);return i}EditorState.allowMultipleSelections=allowMultipleSelections,EditorState.tabSize=Facet.define({combine:t=>t.length?t[0]:4}),EditorState.lineSeparator=lineSeparator,EditorState.readOnly=readOnly,EditorState.phrases=Facet.define({compare(t,e){let n=Object.keys(t),i=Object.keys(e);return n.length==i.length&&n.every((n=>t[n]==e[n]))}}),EditorState.languageData=languageData,EditorState.changeFilter=changeFilter,EditorState.transactionFilter=transactionFilter,EditorState.transactionExtender=transactionExtender,Compartment.reconfigure=StateEffect.define();class RangeValue{eq(t){return this==t}range(t,e=t){return Range.create(t,e,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0,RangeValue.prototype.point=!1,RangeValue.prototype.mapMode=MapMode.TrackDel;class Range{constructor(t,e,n){this.from=t,this.to=e,this.value=n}static create(t,e,n){return new Range(t,e,n)}}function cmpRange(t,e){return t.from-e.from||t.value.startSide-e.value.startSide}class Chunk{constructor(t,e,n,i){this.from=t,this.to=e,this.value=n,this.maxPoint=i}get length(){return this.to[this.to.length-1]}findIndex(t,e,n,i=0){let r=n?this.to:this.from;for(let s=i,o=r.length;;){if(s==o)return s;let i=s+o>>1,a=r[i]-t||(n?this.value[i].endSide:this.value[i].startSide)-e;if(i==s)return a>=0?s:o;a>=0?o=i:s=i+1}}between(t,e,n,i){for(let r=this.findIndex(e,-1e9,!0),s=this.findIndex(n,1e9,!1,r);r<s;r++)if(!1===i(this.from[r]+t,this.to[r]+t,this.value[r]))return!1}map(t,e){let n=[],i=[],r=[],s=-1,o=-1;for(let a=0;a<this.value.length;a++){let h,l,c=this.value[a],f=this.from[a]+t,u=this.to[a]+t;if(f==u){let t=e.mapPos(f,c.startSide,c.mapMode);if(null==t)continue;if(h=l=t,c.startSide!=c.endSide&&(l=e.mapPos(f,c.endSide),l<h))continue}else if(h=e.mapPos(f,c.startSide),l=e.mapPos(u,c.endSide),h>l||h==l&&c.startSide>0&&c.endSide<=0)continue;(l-h||c.endSide-c.startSide)<0||(s<0&&(s=h),c.point&&(o=Math.max(o,l-h)),n.push(c),i.push(h-s),r.push(l-s))}return{mapped:n.length?new Chunk(i,r,n,o):null,pos:s}}}class RangeSet{constructor(t,e,n,i){this.chunkPos=t,this.chunk=e,this.nextLayer=n,this.maxPoint=i}static create(t,e,n,i){return new RangeSet(t,e,n,i)}get length(){let t=this.chunk.length-1;return t<0?0:Math.max(this.chunkEnd(t),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let t=this.nextLayer.size;for(let e of this.chunk)t+=e.value.length;return t}chunkEnd(t){return this.chunkPos[t]+this.chunk[t].length}update(t){let{add:e=[],sort:n=!1,filterFrom:i=0,filterTo:r=this.length}=t,s=t.filter;if(0==e.length&&!s)return this;if(n&&(e=e.slice().sort(cmpRange)),this.isEmpty)return e.length?RangeSet.of(e):this;let o=new LayerCursor(this,null,-1).goto(0),a=0,h=[],l=new RangeSetBuilder;for(;o.value||a<e.length;)if(a<e.length&&(o.from-e[a].from||o.startSide-e[a].value.startSide)>=0){let t=e[a++];l.addInner(t.from,t.to,t.value)||h.push(t)}else 1==o.rangeIndex&&o.chunkIndex<this.chunk.length&&(a==e.length||this.chunkEnd(o.chunkIndex)<e[a].from)&&(!s||i>this.chunkEnd(o.chunkIndex)||r<this.chunkPos[o.chunkIndex])&&l.addChunk(this.chunkPos[o.chunkIndex],this.chunk[o.chunkIndex])?o.nextChunk():((!s||i>o.to||r<o.from||s(o.from,o.to,o.value))&&(l.addInner(o.from,o.to,o.value)||h.push(Range.create(o.from,o.to,o.value))),o.next());return l.finishInner(this.nextLayer.isEmpty&&!h.length?RangeSet.empty:this.nextLayer.update({add:h,filter:s,filterFrom:i,filterTo:r}))}map(t){if(t.empty||this.isEmpty)return this;let e=[],n=[],i=-1;for(let r=0;r<this.chunk.length;r++){let s=this.chunkPos[r],o=this.chunk[r],a=t.touchesRange(s,s+o.length);if(!1===a)i=Math.max(i,o.maxPoint),e.push(o),n.push(t.mapPos(s));else if(!0===a){let{mapped:r,pos:a}=o.map(s,t);r&&(i=Math.max(i,r.maxPoint),e.push(r),n.push(a))}}let r=this.nextLayer.map(t);return 0==e.length?r:new RangeSet(n,e,r||RangeSet.empty,i)}between(t,e,n){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let r=this.chunkPos[i],s=this.chunk[i];if(e>=r&&t<=r+s.length&&!1===s.between(r,t-r,e-r,n))return}this.nextLayer.between(t,e,n)}}iter(t=0){return HeapCursor.from([this]).goto(t)}get isEmpty(){return this.nextLayer==this}static iter(t,e=0){return HeapCursor.from(t).goto(e)}static compare(t,e,n,i,r=-1){let s=t.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=r)),o=e.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=r)),a=findSharedChunks(s,o,n),h=new SpanCursor(s,a,r),l=new SpanCursor(o,a,r);n.iterGaps(((t,e,n)=>compare(h,t,l,e,n,i))),n.empty&&0==n.length&&compare(h,0,l,0,0,i)}static eq(t,e,n=0,i){null==i&&(i=999999999);let r=t.filter((t=>!t.isEmpty&&e.indexOf(t)<0)),s=e.filter((e=>!e.isEmpty&&t.indexOf(e)<0));if(r.length!=s.length)return!1;if(!r.length)return!0;let o=findSharedChunks(r,s),a=new SpanCursor(r,o,0).goto(n),h=new SpanCursor(s,o,0).goto(n);for(;;){if(a.to!=h.to||!sameValues(a.active,h.active)||a.point&&(!h.point||!a.point.eq(h.point)))return!1;if(a.to>i)return!0;a.next(),h.next()}}static spans(t,e,n,i,r=-1){let s=new SpanCursor(t,null,r).goto(e),o=e,a=s.openStart;for(;;){let t=Math.min(s.to,n);if(s.point){let n=s.activeForPoint(s.to),r=s.pointFrom<e?n.length+1:Math.min(n.length,a);i.point(o,t,s.point,n,r,s.pointRank),a=Math.min(s.openEnd(t),n.length)}else t>o&&(i.span(o,t,s.active,a),a=s.openEnd(t));if(s.to>n)return a+(s.point&&s.to>n?1:0);o=s.to,s.next()}}static of(t,e=!1){let n=new RangeSetBuilder;for(let i of t instanceof Range?[t]:e?lazySort(t):t)n.add(i.from,i.to,i.value);return n.finish()}static join(t){if(!t.length)return RangeSet.empty;let e=t[t.length-1];for(let n=t.length-2;n>=0;n--)for(let i=t[n];i!=RangeSet.empty;i=i.nextLayer)e=new RangeSet(i.chunkPos,i.chunk,e,Math.max(i.maxPoint,e.maxPoint));return e}}function lazySort(t){if(t.length>1)for(let e=t[0],n=1;n<t.length;n++){let i=t[n];if(cmpRange(e,i)>0)return t.slice().sort(cmpRange);e=i}return t}RangeSet.empty=new RangeSet([],[],null,-1),RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{finishChunk(t){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,t&&(this.from=[],this.to=[],this.value=[])}constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null}add(t,e,n){this.addInner(t,e,n)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(t,e,n)}addInner(t,e,n){let i=t-this.lastTo||n.startSide-this.last.endSide;if(i<=0&&(t-this.lastFrom||n.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");return!(i<0)&&(250==this.from.length&&this.finishChunk(!0),this.chunkStart<0&&(this.chunkStart=t),this.from.push(t-this.chunkStart),this.to.push(e-this.chunkStart),this.last=n,this.lastFrom=t,this.lastTo=e,this.value.push(n),n.point&&(this.maxPoint=Math.max(this.maxPoint,e-t)),!0)}addChunk(t,e){if((t-this.lastTo||e.value[0].startSide-this.last.endSide)<0)return!1;this.from.length&&this.finishChunk(!0),this.setMaxPoint=Math.max(this.setMaxPoint,e.maxPoint),this.chunks.push(e),this.chunkPos.push(t);let n=e.value.length-1;return this.last=e.value[n],this.lastFrom=e.from[n]+t,this.lastTo=e.to[n]+t,!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(t){if(this.from.length&&this.finishChunk(!1),0==this.chunks.length)return t;let e=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(t):t,this.setMaxPoint);return this.from=null,e}}function findSharedChunks(t,e,n){let i=new Map;for(let e of t)for(let t=0;t<e.chunk.length;t++)e.chunk[t].maxPoint<=0&&i.set(e.chunk[t],e.chunkPos[t]);let r=new Set;for(let t of e)for(let e=0;e<t.chunk.length;e++){let s=i.get(t.chunk[e]);null==s||(n?n.mapPos(s):s)!=t.chunkPos[e]||(null==n?void 0:n.touchesRange(s,s+t.chunk[e].length))||r.add(t.chunk[e])}return r}class LayerCursor{constructor(t,e,n,i=0){this.layer=t,this.skip=e,this.minPoint=n,this.rank=i}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(t,e=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(t,e,!1),this}gotoInner(t,e,n){for(;this.chunkIndex<this.layer.chunk.length;){let e=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(e)||this.layer.chunkEnd(this.chunkIndex)<t||e.maxPoint<this.minPoint))break;this.chunkIndex++,n=!1}if(this.chunkIndex<this.layer.chunk.length){let i=this.layer.chunk[this.chunkIndex].findIndex(t-this.layer.chunkPos[this.chunkIndex],e,!0);(!n||this.rangeIndex<i)&&this.setRangeIndex(i)}this.next()}forward(t,e){(this.to-t||this.endSide-e)<0&&this.gotoInner(t,e,!0)}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}{let t=this.layer.chunkPos[this.chunkIndex],e=this.layer.chunk[this.chunkIndex],n=t+e.from[this.rangeIndex];if(this.from=n,this.to=t+e.to[this.rangeIndex],this.value=e.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(t){if(t==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=t}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next()}compare(t){return this.from-t.from||this.startSide-t.startSide||this.rank-t.rank||this.to-t.to||this.endSide-t.endSide}}class HeapCursor{constructor(t){this.heap=t}static from(t,e=null,n=-1){let i=[];for(let r=0;r<t.length;r++)for(let s=t[r];!s.isEmpty;s=s.nextLayer)s.maxPoint>=n&&i.push(new LayerCursor(s,e,n,r));return 1==i.length?i[0]:new HeapCursor(i)}get startSide(){return this.value?this.value.startSide:0}goto(t,e=-1e9){for(let n of this.heap)n.goto(t,e);for(let t=this.heap.length>>1;t>=0;t--)heapBubble(this.heap,t);return this.next(),this}forward(t,e){for(let n of this.heap)n.forward(t,e);for(let t=this.heap.length>>1;t>=0;t--)heapBubble(this.heap,t);(this.to-t||this.value.endSide-e)<0&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1e9,this.value=null,this.rank=-1;else{let t=this.heap[0];this.from=t.from,this.to=t.to,this.value=t.value,this.rank=t.rank,t.value&&t.next(),heapBubble(this.heap,0)}}}function heapBubble(t,e){for(let n=t[e];;){let i=1+(e<<1);if(i>=t.length)break;let r=t[i];if(i+1<t.length&&r.compare(t[i+1])>=0&&(r=t[i+1],i++),n.compare(r)<0)break;t[i]=n,t[e]=r,e=i}}class SpanCursor{constructor(t,e,n){this.minPoint=n,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=HeapCursor.from(t,e,n)}goto(t,e=-1e9){return this.cursor.goto(t,e),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=t,this.endSide=e,this.openStart=-1,this.next(),this}forward(t,e){for(;this.minActive>-1&&(this.activeTo[this.minActive]-t||this.active[this.minActive].endSide-e)<0;)this.removeActive(this.minActive);this.cursor.forward(t,e)}removeActive(t){remove(this.active,t),remove(this.activeTo,t),remove(this.activeRank,t),this.minActive=findMinIndex(this.active,this.activeTo)}addActive(t){let e=0,{value:n,to:i,rank:r}=this.cursor;for(;e<this.activeRank.length&&(r-this.activeRank[e]||i-this.activeTo[e])>0;)e++;insert(this.active,e,n),insert(this.activeTo,e,i),insert(this.activeRank,e,r),t&&insert(t,e,this.cursor.from),this.minActive=findMinIndex(this.active,this.activeTo)}next(){let t=this.to,e=this.point;this.point=null;let n=this.openStart<0?[]:null;for(;;){let i=this.minActive;if(i>-1&&(this.activeTo[i]-this.cursor.from||this.active[i].endSide-this.cursor.startSide)<0){if(this.activeTo[i]>t){this.to=this.activeTo[i],this.endSide=this.active[i].endSide;break}this.removeActive(i),n&&remove(n,i)}else{if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>t){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}{let t=this.cursor.value;if(t.point){if(!(e&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=t,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=t.endSide,this.cursor.next(),this.forward(this.to,this.endSide);break}this.cursor.next()}else this.addActive(n),this.cursor.next()}}}if(n){this.openStart=0;for(let e=n.length-1;e>=0&&n[e]<t;e--)this.openStart++}}activeForPoint(t){if(!this.active.length)return this.active;let e=[];for(let n=this.active.length-1;n>=0&&!(this.activeRank[n]<this.pointRank);n--)(this.activeTo[n]>t||this.activeTo[n]==t&&this.active[n].endSide>=this.point.endSide)&&e.push(this.active[n]);return e.reverse()}openEnd(t){let e=0;for(let n=this.activeTo.length-1;n>=0&&this.activeTo[n]>t;n--)e++;return e}}function compare(t,e,n,i,r,s){t.goto(e),n.goto(i);let o=i+r,a=i,h=i-e;for(;;){let e=t.to+h-n.to||t.endSide-n.endSide,i=e<0?t.to+h:n.to,r=Math.min(i,o);if(t.point||n.point?t.point&&n.point&&(t.point==n.point||t.point.eq(n.point))&&sameValues(t.activeForPoint(t.to),n.activeForPoint(n.to))||s.comparePoint(a,r,t.point,n.point):r>a&&!sameValues(t.active,n.active)&&s.compareRange(a,r,t.active,n.active),i>o)break;a=i,e<=0&&t.next(),e>=0&&n.next()}}function sameValues(t,e){if(t.length!=e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!=e[n]&&!t[n].eq(e[n]))return!1;return!0}function remove(t,e){for(let n=e,i=t.length-1;n<i;n++)t[n]=t[n+1];t.pop()}function insert(t,e,n){for(let n=t.length-1;n>=e;n--)t[n+1]=t[n];t[e]=n}function findMinIndex(t,e){let n=-1,i=1e9;for(let r=0;r<e.length;r++)(e[r]-i||t[r].endSide-t[n].endSide)<0&&(n=r,i=e[r]);return n}function countColumn(t,e,n=t.length){let i=0;for(let r=0;r<n;)9==t.charCodeAt(r)?(i+=e-i%e,r++):(i++,r=findClusterBreak(t,r));return i}function findColumn(t,e,n,i){for(let i=0,r=0;;){if(r>=e)return i;if(i==t.length)break;r+=9==t.charCodeAt(i)?n-r%n:1,i=findClusterBreak(t,i)}return!0===i?-1:t.length}export{Annotation,AnnotationType,ChangeDesc,ChangeSet,CharCategory,Compartment,EditorSelection,EditorState,Facet,Line,MapMode,Prec,Range,RangeSet,RangeSetBuilder,RangeValue,SelectionRange,StateEffect,StateEffectType,StateField,Text,Transaction,codePointAt,codePointSize,combineConfig,countColumn,findClusterBreak,findColumn,fromCodePoint};